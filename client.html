<!DOCTYPE html>
<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.10/pixi.js" integrity="sha512-9tPO3gqglqiAdSlIxWOBOxl6jTjsFJ2eYwzt/5DZJ3SK1hvhh54bvkKrrCZL3344OyQK+RNf/4sxo+o5WPoVRA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    </head>
    <body>
        <div>
            Alive and well
        </div>

        <div id="game"></div>
    </body>

    <script>
        let requestCount = 0;
        let frames = 0;
        let playerId;
        let unitGraphics = {};
        let gameState;
        let appWidth = 500;
        let appHeight = 500;
        let tileWidth = 50;
        let tileHeight = 50;
        let playerWidth = 20;
        let playerHeight = 20;
        let keysPressed = {
            "left": false,
            "right": false,
            "up": false,
            "down": false,
            "jump": false,
        }
        // let platforms = [];
        let groundWidth = 300;
        let groundHeight = 50;
        let groundX = 100;
        let groundY = 400;
        const platforms = [];
        platforms.push({
            x: 100,
            y: 400,
            width: 300,
            height: 50
        }, {
            x: 250,
            y: 350,
            width: 50,
            height: 50,
        });

        const collidedY = (playerId, y) => {
            for (let platform of platforms){
                if ((gameState[playerId].x + playerWidth) >= platform.x &&
                    gameState[playerId].x <= platform.x + platform.width &&
                    (y + playerHeight) >= platform.y &&
                    y <= platform.y + platform.height){
                        return platform;
                    }
            }
            return null
        }

        const collidedX = (playerId, x) => {
            for (let platform of platforms){
                if ((x + playerWidth) >= platform.x &&
                    x <= platform.x + platform.width &&
                    (gameState[playerId].y + playerHeight) >= platform.y &&
                    gameState[playerId].y <= platform.y + platform.height){
                        return platform;
                    }
            }
            return null
        }

        const updateGameState = (playerId, x, y) => {
            const collidedYPlatform = collidedY(playerId, y);
            const collidedXPlatform = collidedX(playerId, x);

            if (!collidedXPlatform){
                gameState[playerId].x = x;
            } else {
                // Set to left side
                if (gameState[playerId].x < collidedXPlatform.x){
                    gameState[playerId].x = collidedXPlatform.x - playerWidth - 1;
                // set to right side
                } else {
                    gameState[playerId].x = (collidedXPlatform.x + collidedXPlatform.width) + 1
                }
            }

            if (!collidedYPlatform){
                gameState[playerId].y = y;
            } else {
                // Set to top of platform
                if (gameState[playerId].y < collidedYPlatform.y){
                    gameState[playerId].y = collidedYPlatform.y - playerHeight - 1;
                // Set to bottom
                } else {
                    gameState[playerId].y = (collidedYPlatform.y + collidedYPlatform.height) + 1
                }
            }
        }

        const gravity = () => {
            if (gameState[playerId].yVelocity < 16){
                // if (frames % 15){

                    gameState[playerId].yVelocity += 1;
                // }
            }
        }


        // Utils
        const pasteDom = (str) => {
            const div = document.createElement("div");
            div.innerHTML = str;
            document.getElementById("game").appendChild(div);
        }

        const loadGame = (newGameState) => {
            gameState = newGameState;
            Object.keys(gameState).forEach((playerId) => {
                createPlayer(playerId, newGameState);
            })
        }

        const createPlayer = (playerId, newGameState) => {
            unitGraphics[playerId] = new PIXI.Graphics();
            unitGraphics[playerId].beginFill(0xFF0000);
            unitGraphics[playerId].drawRect(newGameState[playerId].x, newGameState[playerId].y, playerWidth, playerHeight);
            gameState[playerId] = newGameState[playerId]
            application.stage.addChild(unitGraphics[playerId]);
        }

        const removePlayer = (playerId) => {
            console.log(`removing player ${playerId}`)
            unitGraphics[playerId].clear();
            application.stage.removeChild(unitGraphics[playerId]);
            delete unitGraphics[playerId];
            delete gameState[playerId];
        }

        const redraw = (playerId, x, y) => {
            unitGraphics[playerId].clear();
            unitGraphics[playerId].beginFill(0xFF0000);
            unitGraphics[playerId].drawRect(x, y, playerWidth, playerHeight);  
        }

        const redrawAll = () => {
            // debugger;
            Object.keys(gameState).forEach((playerId) => {
                redraw(playerId, gameState[playerId].x, gameState[playerId].y)
            });
        }

        // const tempUpdate = (newGameState) => {
        //     Object.keys(newGameState).forEach((playerId) => {
        //         gameState[playerId].xVelocity = newGameState[playerId].xVelocity;
        //         gameState[playerId].yVelocity = newGameState[playerId].yVelocity;
        //         const xDiff = Math.abs(newGameState[playerId].x - gameState[playerId].x);
        //         const yDiff = Math.abs(newGameState[playerId].y - gameState[playerId].y);
        //         console.log(`player ${playerId}: xDiff ${xDiff} and yDiff ${yDiff}`)
        //         // If server and client are 10 or pixels out of sync
        //         // take what the server has
        //         if (xDiff >= 5){
        //             gameState[playerId].x = newGameState[playerId].x;
        //         }
        //         if (yDiff >= 5){
        //             gameState[playerId].y = newGameState[playerId].y;
        //         }
        //     });
        // }

        // Socket stuff
        // const socket = new WebSocket("ws://143.198.233.175:3005");
        const socket = new WebSocket("ws://143.198.233.175:3007");

        // const socket = new WebSocket("ws://localhost:3005");

        socket.onmessage = (ev) => {
            const event = JSON.parse(ev.data);
            switch(event.type){
                case("CONNECTED"):                    
                    pasteDom(`user connected ${event.playerId}`);
                    playerId = event.playerId;
                    loadGame(event.gameState);
                    break;
                case("OPPONENT_CONNECTED"):
                    pasteDom(`opponent connected ${event.playerId}`);
                    createPlayer(event.playerId, event.gameState);
                    break;
                case("OPPONENT_DISCONNECTED"):
                    pasteDom(`opponent disconnected ${event.playerId}`);
                    removePlayer(event.playerId);
                    break;
                case("UPDATE"):
                    gameState = event.gameState;
                    // tempUpdate(event.gameState);
                    // redrawAll();
                    // tempUpdate(event.gameState)
                    break;
                default:
                    throw(`unhandled event ${event.type}`);
            }
        }

        // Game stuff
        const application = new PIXI.Application({
            width: 500,
            height: 500,
        });

        // Create platforms
        const ground = new PIXI.Graphics();
        ground.beginFill(0xA52A2A);
        ground.drawRect(100, 400, 300, 50);
        
        const groundLump = new PIXI.Graphics();
        groundLump.beginFill(0xA52A2A);
        groundLump.drawRect(250, 350, 50, 50);

        platforms.push({
            x: 100,
            y: 400,
            width: 300,
            height: 50
        }, {
            x: 250,
            y: 350,
            width: 50,
            height: 50,
        });
        
        application.stage.addChild(ground, groundLump);
        document.addEventListener("keyup", (ev) => {
            switch(ev.key){
                case("A"):
                case("a"):
                    keysPressed["left"] = false;
                    if (!keysPressed["right"]){
                        socket.send(JSON.stringify({
                            type: "ACTION",
                            action: "stopMoveLeft",
                            playerId,
                        }));
                    }
         
                    break;
                case("D"):
                case("d"):
                    keysPressed["right"] = false;
                    if (!keysPressed["left"]){
                        socket.send(JSON.stringify({
                            type: "ACTION",
                            action: "stopMoveRight",
                            playerId,
                        }));
                    }
                    break;
                case("W"):
                case("w"):
                    keysPressed["up"] = false;
                    if (!keysPressed["down"]){
                        socket.send(JSON.stringify({
                            type: "ACTION",
                            action: "stopMoveUp",
                            playerId,
                        }));
                    }
                  
                    break;
                case("S"):
                case("s"):
                    keysPressed["down"] = false;
                    if (!keysPressed["up"]){
                        socket.send(JSON.stringify({
                            type: "ACTION",
                            action: "stopMoveDown",
                            playerId,
                        }));
                    }
                    break;
                default:
                    break;
  
            }
        });

        document.addEventListener("keypress", (ev) => {
            switch(ev.key){
                case("A"):
                case("a"):
                    keysPressed["left"] = true;
                    socket.send(JSON.stringify({
                        type: "ACTION",
                        action: "moveLeft",
                        playerId,
                    }));
                    break;
                case("D"):
                case("d"):
                    keysPressed["right"] = true;
                    socket.send(JSON.stringify({
                        type: "ACTION",
                        action: "moveRight",
                        playerId,
                    }));
                    break;
                case("W"):
                case("w"):
                    keysPressed["up"] = true;
                    socket.send(JSON.stringify({
                        type: "ACTION",
                        action: "moveUp",
                        playerId,
                    }));
                    break;
                case("S"):
                case("s"):
                    keysPressed["down"] = true;
                    socket.send(JSON.stringify({
                        type: "ACTION",
                        action: "moveDown",
                        playerId,
                    }));
                    break;
                case(" "):
                    ev.preventDefault();
                    socket.send(JSON.stringify({
                        type: "ACTION",
                        action: "jump",
                        playerId,
                    }));
                    break;
            }
        });

        // application.ticker.add((delta) => {
        //     // console.log('game loop');
        //     if (!gameState) return;
        //     redraw(playerId, gameState[playerId].x + gameState[playerId].xVelocity, gameState[playerId].y + gameState[playerId].yVelocity);
        // })

        // application.ticker.maxFPS = ;
        application.ticker.add((delta) => {
            frames += 1;
            if (gameState){
                gravity();
                Object.keys(gameState).forEach((playerId) => {
                    if (gameState[playerId].xVelocity === 0 && gameState[playerId].yVelocity === 0){
                                return;
                    }
                    updateGameState(playerId, gameState[playerId].x + gameState[playerId].xVelocity, gameState[playerId].y + gameState[playerId].yVelocity);
                    redraw(playerId, gameState[playerId].x, gameState[playerId].y);
                });
       
            }
        })

        window.addEventListener("beforeunload", (event) => {
            socket.close(1003);
        });

        document.getElementById("game").appendChild(application.view);
    </script>
</html>